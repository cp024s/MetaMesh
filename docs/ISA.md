# <p align="center">ISA Structure Table</p>

> Notes on columns:
>
> * **Opcode** —   8-bit opcode (hex) for decoder mapping. 
> * **Operands** — canonical operand fields (registers, addresses, immediate fields).
> * **Latency** — typical execution latency in cycles (implementation-dependent)
> * **µ-op expansion** — outline of the micro-ops or internal actions executed for that MOP.
> * **Flags/Effect** — key side-effects (memory, PSUM, mask, exceptions).

---

| Opcode | Instruction      | Category      | Operands (canonical)                                 | Short description                                                         |            Typical latency (cycles) | µ-op expansion (high level)                                           | Flags / Effect                                 |
| -----: | ---------------- | ------------- | ---------------------------------------------------- | ------------------------------------------------------------------------- | ----------------------------------: | --------------------------------------------------------------------- | ---------------------------------------------- |
|   0x01 | `LOAD_IFM`       | Data movement | `dst_scratch, mem_addr, shape, fmt`                  | Load IFM tile from external memory into scratchpad buffer.                |               4–100 (DMA dependent) | DMA_config → DMA_start → wait → write scratch rows                    | Memory read; sets scratch dirty                |
|   0x02 | `LOAD_WEIGHT`    | Data movement | `dst_wbuf, mem_addr, tile_id, layout`                | Load weight tile into local weight buffer.                                |                               4–100 | DMA_config → DMA_start → write weight buffer                          | Memory read; weight buffer updated             |
|   0x03 | `LOAD_PSUM`      | Data movement | `dst_acc, mem_addr, size`                            | Load partial sums into accumulator buffer for accumulation.               |                                4–50 | DMA → PSUM buffer write                                               | Memory read; PSUM initialized                  |
|   0x04 | `STORE_OFM`      | Data movement | `src_scratch, mem_addr, shape`                       | Store OFM tile from scratchpad to external memory.                        |                               4–100 | Read scratch → DMA_config → DMA_start                                 | Memory write; scratch mark cleared             |
|   0x05 | `PREFETCH`       | Data movement | `mem_addr, size, stride`                             | Prefetch region into scratchpad (hinted DMA).                             |                        1–10 (start) | DMA_config (background)                                               | No immediate state change except DMA in flight |
|   0x06 | `DMA_COPY`       | Data movement | `dst_addr, src_addr, size, stride`                   | Direct DMA copy (mem↔mem or mem↔scratch).                                 |                               4–200 | Configure DMA channel → start → completion notify                     | Memory transfer; may set DMA status            |
|   0x07 | `TILE_SLICE`     | Data movement | `dst_scratch, src_scratch, x,y,w,h`                  | Extract a tile/window (im2col helper) within scratchpad.                  |                                2–20 | Address calc → block copy in scratch                                  | Scratch content updated                        |
|   0x08 | `TILE_MERGE`     | Data movement | `dst_scratch, [src_list], pattern`                   | Merge small tiles into larger tile (concatenate).                         |                                2–20 | Multiple local copies → concat                                        | Scratch updated                                |
|   0x09 | `CLEAR_ACC`      | Data movement | `acc_id, range`                                      | Reset accumulator/PSUM region to zero.                                    |                                 1–4 | Zero write to acc banks                                               | PSUM reset                                     |
|   0x0A | `SET_SCRATCHPTR` | Data movement | `reg, base_addr`                                     | Configure scratchpad base pointer / context.                              |                                   1 | Write config reg                                                      | Config change                                  |
|   0x0B | `SET_WEIGHTPTR`  | Data movement | `reg, base_addr`                                     | Configure weight buffer pointer / tile base.                              |                                   1 | Write config reg                                                      | Config change                                  |
|   0x0C | `SET_PSUMPTR`    | Data movement | `reg, base_addr`                                     | Configure PSUM base pointer.                                              |                                   1 | Write config reg                                                      | Config change                                  |
|   0x0D | `DOT_INT8`       | Compute       | `ifm_reg, w_reg, acc_reg, length`                    | Execute INT8 dot product on MAC array over length elements (tile-level).  |                  1–8 per inner step | stream operands → MAC lanes → local reduce → acc write                | Updates accumulator; uses compute units        |
|   0x0E | `DOT_INT16`      | Compute       | `ifm_reg, w_reg, acc_reg, length`                    | 16-bit dot product implemented via multi-pass if needed (time-multiplex). |                 4–32 per inner step | Decompose 16→8 bytes → multiple DOT_INT8 passes → combined accumulate | Updates accumulator; multi-cycle               |
|   0x0F | `MATMUL_BLOCK`   | Compute       | `A_reg, B_reg, C_acc, M,N,K,layout`                  | High-level GEMM block mapped to multiple DOT ops + reductions.            | dependent on sizes (tens–thousands) | Loop: load rows/cols → DOT → REDUCE_SUM → write C_acc                 | Writes PSUM / OFM in scratch                   |
|   0x10 | `CONV_TILE`      | Compute       | `ifm_reg, weight_reg, psum_reg, stride,pad,dilation` | Tile-level convolution by patch extraction + DOTs.                        |            dependent (several DOTs) | For each patch: TILE_SLICE/IM2COL → DOTs → ACCUMULATE                 | Writes PSUM                                    |
|   0x11 | `DEPTHWISE_CONV` | Compute       | `ifm_reg, w_reg, psum_reg, params`                   | Depthwise conv specialized path (per-channel small dot).                  |                           dependent | Per channel small DOTs → acc write                                    | Writes PSUM; low bandwidth                     |
|   0x12 | `REDUCE_SUM`     | Compute       | `src_psum_list, dst, axis`                           | Reduce (sum) partial sums across tiles/lanes along axis.                  |                                1–20 | Tree-reduce across inputs → write dst                                 | Writes dst; may consume PSUMs                  |
|   0x13 | `REDUCE_MAX`     | Compute       | `src_list, dst`                                      | Max reduction across inputs.                                              |                                1–20 | Tree compare & select → write dst                                     | Writes dst                                     |
|   0x14 | `ACCUMULATE`     | Compute       | `acc_reg, part_reg`                                  | Accumulate `part_reg` into `acc_reg` (PSUM += partial).                   |                                 1–4 | Read acc → add → write acc                                            | PSUM updated                                   |
|   0x15 | `BROADCAST`      | Compute       | `src_reg, dst_list, width`                           | Broadcast vector/tile to multiple lanes or tiles.                         |                                 1–3 | Replicate data into buffers / routing                                 | Replicates data                                |
|   0x16 | `TILE_SWAP`      | Compute       | `tileA, tileB`                                       | Swap active compute tile (double buffering).                              |                                   1 | Pointer swap                                                          | Scratch pointer updated atomically             |
|   0x17 | `SPARSE_SCAN`    | Sparsity      | `ifm_reg, mask_reg, window`                          | Generate zero/nonzero mask across lanes/windows.                          |                                 1–4 | Scan bytes → set mask bits                                            | Produces mask                                  |
|   0x18 | `SPARSE_INTRA`   | Sparsity      | `ifm_reg, output_dense, window`                      | Intra-lane compacting: remove zeros inside lane.                          |                                 1–6 | Read lane → select nonzero → pack → write dense                       | Produces dense vector                          |
|   0x19 | `SPARSE_INTER`   | Sparsity      | `lanes[], output[], steal_params`                    | Inter-lane stealing to balance nonzero counts across lanes.               |                                2–12 | Priority search → reassign nonzero entries → pack                     | Updates lane assignments                       |
|   0x1A | `SPARSE_PACK`    | Sparsity      | `dense_reg, packed_reg, index_reg`                   | Pack dense vector & produce indices (value,index).                        |                                 1–6 | Compress → write index vector                                         | Outputs packed form                            |
|   0x1B | `SPARSE_UNPACK`  | Sparsity      | `packed_reg, mask_reg, out_reg`                      | Expand packed sparse vector back into original positions.                 |                                 1–6 | Scatter using indices → fill zeros                                    | Reconstructs original layout                   |
|   0x1C | `SPARSE_COUNT`   | Sparsity      | `ifm_reg, cnt_reg`                                   | Count nonzero elements in tile/region.                                    |                                 1–6 | Popcount on mask → write count                                        | Writes count                                   |
|   0x1D | `SPARSE_BITMASK` | Sparsity      | `ifm_reg, mask_out`                                  | Export bitmask for debugging or telemetry.                                |                                 1–4 | Scan → write mask                                                     | Debug/telemetry                                |
|   0x1E | `SPARSE_REMAP`   | Sparsity      | `ifm_reg, remap_table, out_reg`                      | Reorder lanes according to remap table for load balance.                  |                                 2–8 | Permute lanes → write out                                             | Affects scheduling                             |
|   0x1F | `VADD`           | Vector        | `dst, src1, src2, len, fmt`                          | Element-wise vector addition.                                             |                  1–4 per tile chunk | Read srcs → per-lane add → write dst                                  | ALU update                                     |
|   0x20 | `VMUL`           | Vector        | `dst, src1, src2, len, fmt`                          | Element-wise vector multiply.                                             |                       1–6 per chunk | Multipliers → write dst                                               | ALU update                                     |
|   0x21 | `VSHIFT`         | Vector        | `dst, src, shift_amt, dir`                           | Shift/scale vector elements (quant scaling).                              |                                 1–3 | Shift operations → write dst                                          | ALU update                                     |
|   0x22 | `ACT`            | Vector        | `dst, src, type`                                     | Apply activation function (ReLU, Sigmoid, Tanh, GELU approximation).      |                                 1–8 | Per-element LUT or math → write dst                                   | ALU update                                     |
|   0x23 | `QUANTIZE`       | Vector        | `dst, src, scale, zp, out_fmt`                       | Convert from wider to narrower int with scale & zero-point.               |                                 2–6 | Multiply→round→clamp→write                                            | Writes quantized values                        |
|   0x24 | `DEQUANTIZE`     | Vector        | `dst, src, scale`                                    | Convert quantized values to wider format for compute.                     |                                 2–6 | Convert → write dst                                                   | Writes expanded values                         |
|   0x25 | `SYNC`           | Control       | `stage_mask`                                         | Barrier between pipeline stages (DMU/SEU/CE) — ensures dependency order.  |                                 1–4 | Wait for stage events → release                                       | Synchronization                                |
|   0x26 | `WAIT`           | Control       | `resource_id, cond`                                  | Wait until resource ready (buffer/tile) — conditional stall.              |                            variable | Poll resource or event wait                                           | Can stall PC                                   |
|   0x27 | `CONFIG`         | Control       | `cfg_id, value`                                      | Configure tile size, precision, scheduler policy at runtime.              |                                   1 | Write config regs → flush small caches                                | System config change                           |

---

## Implementation & Usage Notes (concise)

* **Opcode mapping above is suggested**; you can assign different widths or add extensions later.
* **Latencies** are a design guide; actual cycles depend on microarchitecture (MAC count, SRAM bandwidth, NoC).
* **Micro-op expansions** are intentionally high-level; each MOP should be implemented either as a short microcode sequence in a small controller or by dedicated datapath logic for hot ops (e.g., `DOT_INT8`, `SPARSE_*`, `DMA_*`).
* **Memory model:** assume coherent scratchpad per tile and explicit DMA for DRAM. MOPs that read/write external memory must be implemented with DMA controllers and may produce interrupts/events read by `WAIT`/`SYNC`.
* **Sparsity ops** produce masks/indices; `DOT_INT8` can accept either dense lanes or the dense-packed vectors produced by `SPARSE_*` instructions.
* **Accumulators / PSUMs**: `ACCUMULATE`, `REDUCE_SUM`, and `CLEAR_ACC` are the canonical ops to manage partial sums. Implement accumulators in BRAMs/accumulator banks (as in the NPU reference).
* **Control flow:** `CONFIG` and `SET_*PTR` do not directly perform data movement; they set the runtime context. `WAIT` and `SYNC` are used by the compiler/runtime to enforce correct ordering.

---
